# QR Library Comprehensive Test Analysis

**Test Date:** 2025-12-31
**Test Mode:** Comprehensive (6,912 total tests)
**Coverage:** 4 encoders √ó 3 decoders √ó 576 test cases

---

## Executive Summary

### üèÜ WINNER: boombuler/barcode + tuotoo

**Success Rate:** 86.1% (496/576 tests passed)
**Best For:** Medium data (100-1000 bytes), all content types
**Speed:** Moderate (10.0ms encode, 20.1ms decode)

**Key Strengths:**
- ‚úÖ Highest overall success rate (86.1%)
- ‚úÖ Works with ALL content types including binary (86.1%)
- ‚úÖ Excellent performance on medium data sizes (100-1000 bytes)
- ‚úÖ Handles most pixel sizes from 128px to 1024px

**Limitations:**
- ‚ö†Ô∏è Fails at 300 bytes (all pixel sizes 256px+)
- ‚ö†Ô∏è Fails at 700 bytes (pixel sizes 512px+)
- ‚ö†Ô∏è Cannot encode 2500 bytes (exceeds capacity)
- ‚ö†Ô∏è Slower decode times (20ms avg vs 1-5ms for others)

---

## Rankings: All Encoder/Decoder Combinations

| Rank | Encoder | Decoder | Success Rate | Tests Passed | Avg Encode | Avg Decode |
|------|---------|---------|--------------|--------------|------------|------------|
| 1 ü•á | **boombuler** | **tuotoo** | **86.1%** | 496/576 | 10.0ms | 20.1ms |
| 2 ü•à | boombuler | goqr | 66.5% | 383/576 | 10.0ms | 27.4ms |
| 3 ü•â | gozxing | gozxing | 63.7% | 367/576 | 2.3ms ‚ö° | 1.4ms ‚ö° |
| 4 | yeqown | gozxing | 61.8% | 356/576 | 13.3ms | 5.7ms |
| 5 | boombuler | gozxing | 59.5% | 343/576 | 10.1ms | 2.0ms |
| 6 | skip2 | gozxing | 54.2% | 312/576 | 4.5ms | 1.6ms |
| 7 | yeqown | goqr | 53.3% | 307/576 | 13.2ms | 27ms+ |
| 8 | skip2 | goqr | 43.4% | 250/576 | 4.4ms | 27ms+ |
| 9 | yeqown | tuotoo | 42.2% | 243/576 | 13.2ms | N/A |
| 10 | gozxing | goqr | 29.0% | 167/576 | 2.2ms | 27ms+ |
| 11 | skip2 | tuotoo | 24.7% | 142/576 | 4.5ms | 16.6ms |
| 12 ‚ùå | gozxing | tuotoo | 14.9% | 86/576 | 2.2ms | N/A |

‚ö° = Fastest in category

---

## Critical Finding: Binary Data Is ENCODER-SPECIFIC

### üîç Initial Report Was Wrong!

The preliminary analysis reported "ALL combinations show 0% binary success" - **this is INCORRECT**.

### ‚úÖ Binary Data Actually Works With boombuler Encoder

| Encoder | Binary Success Rate | Details |
|---------|---------------------|---------|
| **boombuler** | **86.1%** ‚úÖ | Works with all decoders! |
| **skip2** | **~60-70%** ‚úÖ | Works moderately well |
| **yeqown** | **~60-70%** ‚úÖ | Works moderately well |
| **gozxing** | **0%** ‚ùå | COMPLETELY FAILS |

### Root Cause

**gozxing encoder cannot handle binary data generated by `generateBinary()`**

The binary test data uses `rand.Read()` with deterministic seed (line 272 in generator.go):
```go
src := rand.NewSource(42)
rng := rand.New(src)
data := make([]byte, size)
rng.Read(data)
```

This generates truly random bytes (0x00-0xFF), which gozxing encoder cannot process.

**boombuler encoder handles binary correctly** by using `qr.Unicode` mode which forces byte encoding.

### Recommendation

**For binary data support, ALWAYS use boombuler encoder.**

---

## Medium Data Performance (100-1000 bytes)

This is your primary use case. Here's the detailed breakdown:

### boombuler + tuotoo (86.1% overall)

| Data Size | Min Pixel Size | Success at Common Sizes | Notes |
|-----------|----------------|------------------------|-------|
| 100 bytes | 128px ‚úì | All sizes work (128-1024px) | Perfect |
| 200 bytes | 128px ‚úì | Small pixels only (128-200px) | Fails 480px+ |
| 300 bytes | ‚ùå FAILS | Only 128-200px work | Critical issue |
| 500 bytes | 128px ‚úì | All sizes work | Perfect |
| 700 bytes | 128px ‚úì | Works up to 480px | Fails 512px+ |
| 1000 bytes | 128px ‚úì | All sizes work | Perfect |

**Pattern:** 200, 300, and 700 bytes have specific pixel size failures with tuotoo decoder.

**Error:** "not found error correction level and mask"

### boombuler + goqr (66.5% overall)

| Data Size | Min Pixel Size | Success at Common Sizes | Notes |
|-----------|----------------|------------------------|-------|
| 100 bytes | 128px ‚úì | All sizes work | Perfect |
| 200 bytes | 128px ‚úì | All sizes work | Perfect |
| 300 bytes | 200px ‚úì | Fails at 128px only | Good |
| 500 bytes | 200px ‚úì | Fails at 128px only | Good |
| 700 bytes | 256px ‚úì | Needs 256px+ | Moderate |
| 1000 bytes | 256px ‚úì | Works 256-480px | Fails 512px+ |

**Pattern:** Needs larger pixel sizes as data grows. Recognition failures at small pixels.

**Error:** "no QR code in image" (recognition issue)

### gozxing + gozxing (63.7% overall, FASTEST)

| Data Size | Min Pixel Size | Success at Common Sizes | Notes |
|-----------|----------------|------------------------|-------|
| 100 bytes | 128px ‚úì | All sizes work | Perfect |
| 200 bytes | 128px ‚ö†Ô∏è | ONLY 128px works! | Critical |
| 300 bytes | 128px ‚úì | All sizes work | Perfect |
| 500 bytes | 128px ‚úì | All sizes work | Perfect |
| 700 bytes | ‚ùå FAILS | ALL pixel sizes fail | Critical |
| 1000 bytes | 128px ‚úì | All sizes work | Perfect |

**Pattern:** Specific data sizes (200, 700) completely fail across all pixel sizes.

**Errors:**
- Small data: Padding/data mismatch (got extra bytes)
- 200 bytes: Dimension errors
- 700 bytes: Complete failure

---

## Data Type Performance Comparison

### boombuler + tuotoo

| Content Type | Success Rate | Best For |
|--------------|--------------|----------|
| Alphanumeric | 90.3% | ‚úÖ Excellent |
| Binary | 86.1% | ‚úÖ **ONLY encoder that works!** |
| Numeric | 88.2% | ‚úÖ Excellent |
| UTF-8 | 79.9% | ‚úÖ Good |

### boombuler + goqr

| Content Type | Success Rate | Best For |
|--------------|--------------|----------|
| Alphanumeric | 66.7% | ‚ö†Ô∏è Moderate |
| Binary | 68.8% | ‚úÖ Works |
| Numeric | 65.3% | ‚ö†Ô∏è Moderate |
| UTF-8 | 65.3% | ‚ö†Ô∏è Moderate |

### gozxing + gozxing

| Content Type | Success Rate | Best For |
|--------------|--------------|----------|
| Alphanumeric | 95.8% | ‚úÖ **BEST** |
| Binary | 0.0% | ‚ùå **FAILS COMPLETELY** |
| Numeric | 100.0% | ‚úÖ **PERFECT** |
| UTF-8 | 59.0% | ‚ö†Ô∏è Moderate |

---

## Production Recommendations

### For Your Use Case (Medium Data: 100-1000 bytes)

#### Option 1: Maximum Compatibility (Recommended)

**Use: boombuler/barcode encoder + tuotoo decoder**

**Configuration:**
```go
encoder := &encoders.BoombulerEncoder{}
decoder := &decoders.TuotooDecoder{}
```

**Minimum Pixel Sizes:**
- 100 bytes: 256px (safe), 128px (works)
- 200 bytes: 256px (to avoid tuotoo issues)
- 300 bytes: **Use 200px or less** (avoid this size if possible)
- 500 bytes: 320px (safe), 128px (works)
- 700 bytes: **Use 480px or less** (avoid 512px+)
- 1000 bytes: 400px (safe), 128px (works)

**Safe Default:** **480px for all medium data sizes**

**Content Types:**
- ‚úÖ Numeric: Excellent
- ‚úÖ Alphanumeric: Excellent
- ‚úÖ Binary: Only option that works!
- ‚úÖ UTF-8: Good

**Caveats:**
- Avoid 300 bytes at 256px+ (use 200px or different size)
- Avoid 700 bytes at 512px+ (use 480px or different size)
- Slower decode (20ms) than alternatives

#### Option 2: Maximum Speed

**Use: gozxing/encoder + gozxing decoder**

**Configuration:**
```go
encoder := &encoders.GozxingEncoder{}
decoder := &decoders.GozxingDecoder{}
```

**Speed:** 2.3ms encode + 1.4ms decode = 3.7ms total (vs 30ms for boombuler+tuotoo)

**Minimum Pixel Sizes:**
- All sizes: 256px (safe default)

**Content Types:**
- ‚úÖ Numeric: Perfect (100%)
- ‚úÖ Alphanumeric: Excellent (95.8%)
- ‚ùå Binary: **DOES NOT WORK** (0%)
- ‚ö†Ô∏è UTF-8: Moderate (59%)

**Caveats:**
- **CANNOT use binary data**
- Fails completely at 200 and 700 bytes
- Small data has padding issues

#### Option 3: Balanced

**Use: boombuler/barcode encoder + gozxing decoder**

**Success Rate:** 59.5% (lower than top options)

**Speed:** 10.1ms encode + 2.0ms decode = 12.1ms total

Not recommended - lower success rate than Option 1, not much faster.

---

## Edge Cases to Avoid

### Critical: Do NOT Use These Combinations

| Data Size | Pixel Size | Encoder | Decoder | Issue |
|-----------|-----------|---------|---------|-------|
| 300 bytes | 256px+ | boombuler | tuotoo | Complete failure |
| 700 bytes | 512px+ | boombuler | tuotoo | Complete failure |
| 200 bytes | 200px+ | gozxing | gozxing | Only 128px works |
| 700 bytes | ANY | gozxing | gozxing | ALL fail |
| 2500 bytes | ANY | boombuler | ANY | Exceeds capacity |

### Small Data Issues (10, 25 bytes)

All combinations have padding/data mismatch issues with very small payloads:
- 10 bytes returns 14-22 bytes
- 25 bytes returns 27-53 bytes

**Recommendation:** Avoid QR codes for data <50 bytes. Use barcodes or direct encoding instead.

### Large Data Limits

- **boombuler:** Max ~2000 bytes, 2500 fails ("To much data to encode")
- **Others:** Can handle up to 2000 bytes at large pixel sizes (600px+)

For 1500-2000 bytes, need 200px+ pixel size.

---

## Minimum Viable Pixel Sizes

Based on >90% success rate for medium data (100-1000 bytes):

### By Combination

| Data Size | boombuler+tuotoo | boombuler+goqr | gozxing+gozxing |
|-----------|------------------|----------------|-----------------|
| 100 bytes | 128px | 128px | 128px |
| 200 bytes | **200px** ‚ö†Ô∏è | 128px | **128px only!** ‚ö†Ô∏è |
| 300 bytes | **128-200px only!** ‚ùå | 200px | 128px |
| 500 bytes | 128px | 200px | 128px |
| 700 bytes | **256-480px only!** ‚ö†Ô∏è | 256px | **FAILS!** ‚ùå |
| 1000 bytes | 128px | 256px | 128px |

### Safe Production Defaults

**For boombuler + tuotoo (recommended):**

| Data Size Range | Recommended Pixel Size |
|-----------------|------------------------|
| 100-200 bytes | 256px |
| 201-500 bytes | 400px |
| 501-1000 bytes | 480px |
| 1001-2000 bytes | 720px |

**Universal Safe Size:** **480px works for almost everything** (except avoid 700 bytes)

---

## Implementation Guide

### Example Code

```go
import (
	"github.com/13rac1/qr-library-test/internal/encoders"
	"github.com/13rac1/qr-library-test/internal/decoders"
)

// For maximum compatibility (recommended for medium data)
func createQRCode(data []byte) (image.Image, error) {
	encoder := &encoders.BoombulerEncoder{}
	opts := encoders.EncodeOptions{
		ErrorCorrectionLevel: encoders.ErrorCorrectionM,
		PixelSize:            480, // Safe default
	}
	return encoder.Encode(data, opts)
}

func readQRCode(img image.Image) ([]byte, error) {
	decoder := &decoders.TuotooDecoder{}
	return decoder.Decode(img)
}

// For maximum speed (no binary support)
func createQRCodeFast(data []byte) (image.Image, error) {
	encoder := &encoders.GozxingEncoder{}
	opts := encoders.EncodeOptions{
		ErrorCorrectionLevel: encoders.ErrorCorrectionM,
		PixelSize:            256, // Safe default for speed
	}
	return encoder.Encode(data, opts)
}

func readQRCodeFast(img image.Image) ([]byte, error) {
	decoder := &decoders.GozxingDecoder{}
	return decoder.Decode(img)
}
```

### Data Size Selection

**Avoid these problematic sizes if possible:**
- 200 bytes (with gozxing encoder)
- 300 bytes (with boombuler + tuotoo at large pixel sizes)
- 700 bytes (with boombuler + tuotoo at 512px+, or gozxing encoder entirely)

**Use these reliable sizes:**
- 100, 500, 1000 bytes work excellently across all combinations

### Content Type Selection

**For boombuler encoder:**
- ‚úÖ Any content type works
- ‚úÖ **ONLY option for binary data**

**For gozxing encoder:**
- ‚úÖ Numeric: Perfect (use this for numbers)
- ‚úÖ Alphanumeric: Excellent (use this for text)
- ‚ùå Binary: Does not work
- ‚ö†Ô∏è UTF-8: Moderate (test thoroughly)

---

## Summary: Quick Decision Matrix

| Your Need | Use This | Success Rate | Speed |
|-----------|----------|--------------|-------|
| **Best overall** | boombuler + tuotoo | 86.1% | Moderate (30ms) |
| **Binary data required** | boombuler + tuotoo | 86.1% | Moderate |
| **Maximum speed** | gozxing + gozxing | 63.7% | Fast (3.7ms) |
| **Numeric data only** | gozxing + gozxing | 100% | Fast |
| **Alphanumeric only** | gozxing + gozxing | 95.8% | Fast |
| **Balanced** | boombuler + goqr | 66.5% | Slow (37ms) |

**For production (medium data 100-1000 bytes):**
‚úÖ **Use boombuler/barcode encoder + tuotoo decoder at 480px**

Avoid 300 and 700 byte sizes, or use pixel sizes 128-200px for 300 bytes and 256-480px for 700 bytes.
